<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Memcheck on Robert Xu</title>
    <link>https://www.robxu9.com/tags/memcheck/</link>
    <description>Recent content in Memcheck on Robert Xu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>me@robxu9.com (Robert Xu)</managingEditor>
    <webMaster>me@robxu9.com (Robert Xu)</webMaster>
    <copyright>Â© 2014-2015 Robert Xu. All Rights Reserved. Content not indicative of any addl party.</copyright>
    <lastBuildDate>Tue, 05 Aug 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.robxu9.com/tags/memcheck/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>valgrind is important</title>
      <link>https://www.robxu9.com/2014/08/valgrind-is-important/</link>
      <pubDate>Tue, 05 Aug 2014 00:00:00 +0000</pubDate>
      <author>me@robxu9.com (Robert Xu)</author>
      <guid>https://www.robxu9.com/2014/08/valgrind-is-important/</guid>
      <description>

&lt;p&gt;Most people have heard of debugging tools like &lt;code&gt;gdb&lt;/code&gt;. For the rest, it&amp;rsquo;s
usually just continuous testing and catching problems with your eye. But
sometimes it&amp;rsquo;s not that simple.&lt;/p&gt;

&lt;p&gt;Take for example (and I&amp;rsquo;ve been using this example &lt;strong&gt;a lot&lt;/strong&gt;), &lt;code&gt;libdpx&lt;/code&gt;. I was
trying to clean up the code for the past two days, but when I moved a simple
statement that should work, everything essentially went to hell. You can see
that commit &lt;a href=&#34;https://github.com/robxu9/duplex/commit/663bb6de4b52930d1a14
ee86777f69eb1d2f9d99#diff-53207fdef530e854ec6cdb342eef1970R120&#34;&gt;here&lt;/a&gt;. Basically, the
&lt;code&gt;alchanfree()&lt;/code&gt; method is commented because if I tried to &lt;code&gt;chanfree()&lt;/code&gt;,
segfaults would be everywhere.&lt;/p&gt;

&lt;p&gt;At first glance, this doesn&amp;rsquo;t look bad - we&amp;rsquo;re initialising a new channel, then
sending the frame to the write frames method. Then we wait for something to
come back. Because of cooperative threading, everything should work just
dandily.&lt;/p&gt;

&lt;p&gt;But when I uncommented the &lt;code&gt;alchanfree()&lt;/code&gt; method, stuff didn&amp;rsquo;t work. And I was
utterly confused. I was wondering why all of a sudden, I was getting segfaults
left and right.&lt;/p&gt;

&lt;h4 id=&#34;enter-valgrind:8198804284f5f45e50df30e1088b1d71&#34;&gt;enter valgrind&lt;/h4&gt;

&lt;p&gt;Valgrind is this tool that not many people have heard of for some reason, yet
it is one of the most invaluable tools for memory checking that you could ever
have. It basically acts as a middle man between your program and libc,
catching &lt;code&gt;free/malloc/calloc/realloc&lt;/code&gt; calls and recording addresses, then
making sure whatever calls you &amp;lsquo;&lt;code&gt;alloc&lt;/code&gt; are &lt;code&gt;free&lt;/code&gt;&amp;rsquo;d later. As a result, it can
also detect reads and writes to &lt;code&gt;free&lt;/code&gt;&amp;rsquo;d pieces of memory, which would segfault
under normal conditions.&lt;/p&gt;

&lt;p&gt;But most people just ignore what &lt;code&gt;valgrind&lt;/code&gt; is saying. That&amp;rsquo;s bad. Don&amp;rsquo;t do that.&lt;/p&gt;

&lt;p&gt;Some sample output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==802== Memcheck, a memory error detector
==802== Copyright (C) 2002-2013, and GNU GPL&#39;d, by Julian Seward et al.
==802== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==802== Command: ./check_dpx
==802== 
==802== Syscall param timer_create(evp) points to uninitialised byte(s)
==802==    at 0x385AC03E72: timer_create@@GLIBC_2.3.3 (timer_create.c:82)
==802==    by 0x526E47B: srunner_run (check_run.c:407)
==802==    by 0x40361A: main (check.c:499)
==802==  Location 0xffefff750 is 0 bytes inside local_evp._sigev_un,
==802==  declared at timer_create.c:57, in frame #0 of thread 1
==802==  Uninitialised value was created by a stack allocation
==802==    at 0x3859015185: _dl_runtime_resolve (dl-trampoline.S:46)
==802== 
==830== HEAP SUMMARY:
==830==     in use at exit: 572,679 bytes in 96 blocks
==830==   total heap usage: 339 allocs, 243 frees, 1,510,826 bytes allocated
==830== 
==830== 3 bytes in 1 blocks are definitely lost in loss record 5 of 83
==830==    at 0x4A0645D: malloc (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==830==    by 0x4C1A428: _dpx_frame_msgpack_from (frame.c:171)
==830==    by 0x4C149DB: _dpx_duplex_conn_read_frames (conn.c:60)
==830==    by 0x4E5948B: taskstart (task.c:71)
==830==    by 0x38594479FF: ??? (in /usr/lib64/libc-2.18.so)
==830== 
==830== 72 bytes in 1 blocks are definitely lost in loss record 66 of 83
==830==    at 0x4A0645D: malloc (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==830==    by 0x4C174BD: dpx_frame_new (frame.c:27)
==830==    by 0x402700: test_dpx_call (check.c:224)
==830==    by 0x4029E6: test_dpx_rpc_call (check.c:279)
==830==    by 0x526E87D: srunner_run (check_run.c:396)
==830==    by 0x40361A: main (check.c:499)
==830== 
==830== 288 bytes in 1 blocks are possibly lost in loss record 72 of 83
==830==    at 0x4A081D4: calloc (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==830==    by 0x3859011C44: _dl_allocate_tls (dl-tls.c:296)
==830==    by 0x3859808862: pthread_create@@GLIBC_2.2.5 (allocatestack.c:580)
==830==    by 0x4C1BCD5: dpx_init (dpx.c:172)
==830==    by 0x4028F1: test_dpx_rpc_call (check.c:263)
==830==    by 0x526E87D: srunner_run (check_run.c:396)
==830==    by 0x40361A: main (check.c:499)
==830== 
==830== LEAK SUMMARY:
==830==    definitely lost: 75 bytes in 2 blocks
==830==    indirectly lost: 0 bytes in 0 blocks
==830==      possibly lost: 288 bytes in 1 blocks
==830==    still reachable: 572,316 bytes in 93 blocks
==830==         suppressed: 0 bytes in 0 blocks
==830== Reachable blocks (those to which a pointer was found) are not shown.
==830== To see them, rerun with: --leak-check=full --show-leak-kinds=all
==830== 
==830== For counts of detected and suppressed errors, rerun with: -v
==830== ERROR SUMMARY: 7 errors from 4 contexts (suppressed: 2 from 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All that output looks, frankly, terrifying at first. But it&amp;rsquo;s actually not that
hard to interpret. It tells you how many blocks of memory it thinks are lost,
and where they were allocated. That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;How about output for invalid reads?&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t have those, because I rage&amp;hellip; obliterated them. Yes. That.&lt;/p&gt;

&lt;p&gt;My problem was that something was trying to write to the channel after it was
free&amp;rsquo;d. That has now been solved, thanks to valgrind outputting 8 pages of
&amp;ldquo;invalid write of size 8, here (insert stacktrace), to a block that was free&amp;rsquo;d
here (insert stacktrace)&amp;ldquo;.&lt;/p&gt;

&lt;h4 id=&#34;valgrind-treats-you-like-you-don-t-know-what-you-re-doing:8198804284f5f45e50df30e1088b1d71&#34;&gt;valgrind treats you like you don&amp;rsquo;t know what you&amp;rsquo;re doing&lt;/h4&gt;

&lt;p&gt;In my case, that&amp;rsquo;s probably true. Manual memory management sucks.&lt;/p&gt;

&lt;p&gt;But it&amp;rsquo;s good, because there&amp;rsquo;s definitely way more actual errors detected than
false positives. Case in point, here was my recycling bin after I printed out
my valgrind output and went through all of them one by one:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.robxu9.com/media/2014-08-05-valgrind-is-important/2014-08-05 18.05.13
.jpg&#34; alt=&#34;so much paper...&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I feel old-fashioned because I do code reviews on paper, but hey, it&amp;rsquo;s easier
for me. I can&amp;rsquo;t be the only one who agrees&amp;hellip; right?&lt;/p&gt;

&lt;h4 id=&#34;so-what-are-you-trying-to-tell-me:8198804284f5f45e50df30e1088b1d71&#34;&gt;so what are you trying to tell me&lt;/h4&gt;

&lt;p&gt;Valgrind your program. It&amp;rsquo;s good for detecting memory leaks and the likes of it
, can tell you when you&amp;rsquo;re trying to murder poor memory fields you don&amp;rsquo;t have
access to, and also other cool things. Really.&lt;/p&gt;

&lt;p&gt;Here, I&amp;rsquo;ll get you started! You can run valgrind with
&lt;code&gt;valgrind --leak-check=yes --read-var-info=yes --track-origins=yes ./[program]&lt;/code&gt;
and receive your lovely output. By default, valgrind prints to stderr. Redirect
it to stdout if you want to pipe it to &lt;code&gt;ansi2html&lt;/code&gt; or something similar to
to print it out.&lt;/p&gt;

&lt;h4 id=&#34;what-was-the-point-of-this-article:8198804284f5f45e50df30e1088b1d71&#34;&gt;what was the point of this article&lt;/h4&gt;

&lt;p&gt;I don&amp;rsquo;t know, just that I had a problem, used Valgrind, solved said problem?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
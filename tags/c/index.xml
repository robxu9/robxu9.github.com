<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on Robert Xu</title>
    <link>https://www.robxu9.com/tags/c/</link>
    <description>Recent content in C on Robert Xu</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>me@robxu9.com (Robert Xu)</managingEditor>
    <webMaster>me@robxu9.com (Robert Xu)</webMaster>
    <copyright>Â© 2014-2015 Robert Xu. All Rights Reserved. Content not indicative of any addl party.</copyright>
    <lastBuildDate>Sat, 17 Jan 2015 00:09:29 -0600</lastBuildDate>
    <atom:link href="https://www.robxu9.com/tags/c/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>duplex in C, take two</title>
      <link>https://www.robxu9.com/2015/01/duplex-in-c-take-two/</link>
      <pubDate>Sat, 17 Jan 2015 00:09:29 -0600</pubDate>
      <author>me@robxu9.com (Robert Xu)</author>
      <guid>https://www.robxu9.com/2015/01/duplex-in-c-take-two/</guid>
      <description>

&lt;p&gt;I seem to be doing a bunch of rewrites of my older projects nowadays. But
sometimes that&amp;rsquo;s necessary. It is for the case of duplex (and libduplex).&lt;/p&gt;

&lt;h3 id=&#34;background:dbd361d9d83ece52b494a1b526aef755&#34;&gt;Background&lt;/h3&gt;

&lt;p&gt;When I was working at DigitalOcean over the past summer, my main project was
a communication framework called &lt;a href=&#34;https://github.com/progrium/duplex&#34;&gt;duplex&lt;/a&gt;.
Duplex&amp;rsquo;s aim was to create a simple messaging framework that could potentially
be used for RPC. The first version was prototyped in Go, and I created
&lt;code&gt;libdpx&lt;/code&gt;, which was the first version in C.&lt;/p&gt;

&lt;p&gt;Unfortunately, &lt;code&gt;libdpx&lt;/code&gt; had some major flaws - I didn&amp;rsquo;t use a proper build
system, I used &lt;code&gt;libtask&lt;/code&gt; for coroutines (switching that out with &lt;code&gt;lthread&lt;/code&gt;,
then switching back to &lt;code&gt;libtask&lt;/code&gt; after &lt;code&gt;lthread&lt;/code&gt; didn&amp;rsquo;t work with shared
libraries), and in general I didn&amp;rsquo;t manage memory well. You could lose data
along the way with the race conditions.&lt;/p&gt;

&lt;p&gt;Jeff realised that a lot of the things we wanted to implement with duplex
would be hard, because essentially we were creating a new protocol. So
recently, he took to creating a second version in Go, but this time
sitting on top of the SSH protocol.&lt;/p&gt;

&lt;p&gt;The SSH protocol provides a bunch of the logic so that we don&amp;rsquo;t have to
worry about it - authentication, security, and channel management. This
was our way of wrapping it in a user friendly form.&lt;/p&gt;

&lt;h3 id=&#34;libduplex:dbd361d9d83ece52b494a1b526aef755&#34;&gt;libduplex&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;libduplex&lt;/code&gt; is the second version of duplex in C. However, this time, I&amp;rsquo;m
being extra careful to, essentially, not fuck up the threading. This time
there are no lightweight coroutines or &lt;code&gt;libtask&lt;/code&gt;; instead, I directly call
pthreads in order to manage calls. The API is still threadsafe, and I still
run a thread dedicated to each ssh session (because libssh does not support
multiple threads working on sessions, which is understandable given the
complexity of the task - but it does have a non-blocking mode, and I rely
on that). Currently you can bind to tcp and unix sockets, and if any other
reliable protocol becomes available, I will gladly implement that.&lt;/p&gt;

&lt;p&gt;The intent behind this is to make the Go version and C version be fully
compatible. I will not &lt;code&gt;cgo&lt;/code&gt; these bindings this time, because that seems
like a poor idea if they&amp;rsquo;re both going to be the same - the pure Go version
would work better in Go. However, there is an interest in making a Python
version for libduplex, which I will get around to after &lt;code&gt;libduplex&lt;/code&gt; is
fully compatible with the already existing Go counterpart.&lt;/p&gt;

&lt;h3 id=&#34;managing-time:dbd361d9d83ece52b494a1b526aef755&#34;&gt;Managing Time&lt;/h3&gt;

&lt;p&gt;The last duplex suffered immensely from a lack of manpower - Jeff has his
own projects and clients to focus on, and I have university which I have
to concentrate on. However, I don&amp;rsquo;t intend to abandon this at all - if
possible, I&amp;rsquo;d like this second version to become the main version of duplex.&lt;/p&gt;

&lt;p&gt;We want to take duplex further, too. Not just for standard communication
and RPC between applications, but further into plugin systems, APIs over
the internet, and more.&lt;/p&gt;

&lt;p&gt;So I definitely want to keep working on it despite university.&lt;/p&gt;

&lt;p&gt;(You can make my life slightly easier by making pull requests.)&lt;/p&gt;

&lt;h3 id=&#34;where-from-here:dbd361d9d83ece52b494a1b526aef755&#34;&gt;Where from here?&lt;/h3&gt;

&lt;p&gt;Going from here remains to be seen. My immediate priorities are getting
libduplex off the ground so that it can be at least used in a beta state.
Maybe even declare it 1.0 if it gets to be good enough without any major
flaws.&lt;/p&gt;

&lt;p&gt;But I&amp;rsquo;m heading along for the ride and I definitely want to see what happens.&lt;/p&gt;

&lt;h3 id=&#34;github:dbd361d9d83ece52b494a1b526aef755&#34;&gt;Github&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/robxu9/libduplex&#34;&gt;libduplex&lt;/a&gt; is licensed under the MIT
license. See &lt;code&gt;HACKING&lt;/code&gt; for building instructions and more.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>valgrind is important</title>
      <link>https://www.robxu9.com/2014/08/valgrind-is-important/</link>
      <pubDate>Tue, 05 Aug 2014 00:00:00 +0000</pubDate>
      <author>me@robxu9.com (Robert Xu)</author>
      <guid>https://www.robxu9.com/2014/08/valgrind-is-important/</guid>
      <description>

&lt;p&gt;Most people have heard of debugging tools like &lt;code&gt;gdb&lt;/code&gt;. For the rest, it&amp;rsquo;s
usually just continuous testing and catching problems with your eye. But
sometimes it&amp;rsquo;s not that simple.&lt;/p&gt;

&lt;p&gt;Take for example (and I&amp;rsquo;ve been using this example &lt;strong&gt;a lot&lt;/strong&gt;), &lt;code&gt;libdpx&lt;/code&gt;. I was
trying to clean up the code for the past two days, but when I moved a simple
statement that should work, everything essentially went to hell. You can see
that commit &lt;a href=&#34;https://github.com/robxu9/duplex/commit/663bb6de4b52930d1a14
ee86777f69eb1d2f9d99#diff-53207fdef530e854ec6cdb342eef1970R120&#34;&gt;here&lt;/a&gt;. Basically, the
&lt;code&gt;alchanfree()&lt;/code&gt; method is commented because if I tried to &lt;code&gt;chanfree()&lt;/code&gt;,
segfaults would be everywhere.&lt;/p&gt;

&lt;p&gt;At first glance, this doesn&amp;rsquo;t look bad - we&amp;rsquo;re initialising a new channel, then
sending the frame to the write frames method. Then we wait for something to
come back. Because of cooperative threading, everything should work just
dandily.&lt;/p&gt;

&lt;p&gt;But when I uncommented the &lt;code&gt;alchanfree()&lt;/code&gt; method, stuff didn&amp;rsquo;t work. And I was
utterly confused. I was wondering why all of a sudden, I was getting segfaults
left and right.&lt;/p&gt;

&lt;h4 id=&#34;enter-valgrind:8198804284f5f45e50df30e1088b1d71&#34;&gt;enter valgrind&lt;/h4&gt;

&lt;p&gt;Valgrind is this tool that not many people have heard of for some reason, yet
it is one of the most invaluable tools for memory checking that you could ever
have. It basically acts as a middle man between your program and libc,
catching &lt;code&gt;free/malloc/calloc/realloc&lt;/code&gt; calls and recording addresses, then
making sure whatever calls you &amp;lsquo;&lt;code&gt;alloc&lt;/code&gt; are &lt;code&gt;free&lt;/code&gt;&amp;rsquo;d later. As a result, it can
also detect reads and writes to &lt;code&gt;free&lt;/code&gt;&amp;rsquo;d pieces of memory, which would segfault
under normal conditions.&lt;/p&gt;

&lt;p&gt;But most people just ignore what &lt;code&gt;valgrind&lt;/code&gt; is saying. That&amp;rsquo;s bad. Don&amp;rsquo;t do that.&lt;/p&gt;

&lt;p&gt;Some sample output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;==802== Memcheck, a memory error detector
==802== Copyright (C) 2002-2013, and GNU GPL&#39;d, by Julian Seward et al.
==802== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==802== Command: ./check_dpx
==802== 
==802== Syscall param timer_create(evp) points to uninitialised byte(s)
==802==    at 0x385AC03E72: timer_create@@GLIBC_2.3.3 (timer_create.c:82)
==802==    by 0x526E47B: srunner_run (check_run.c:407)
==802==    by 0x40361A: main (check.c:499)
==802==  Location 0xffefff750 is 0 bytes inside local_evp._sigev_un,
==802==  declared at timer_create.c:57, in frame #0 of thread 1
==802==  Uninitialised value was created by a stack allocation
==802==    at 0x3859015185: _dl_runtime_resolve (dl-trampoline.S:46)
==802== 
==830== HEAP SUMMARY:
==830==     in use at exit: 572,679 bytes in 96 blocks
==830==   total heap usage: 339 allocs, 243 frees, 1,510,826 bytes allocated
==830== 
==830== 3 bytes in 1 blocks are definitely lost in loss record 5 of 83
==830==    at 0x4A0645D: malloc (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==830==    by 0x4C1A428: _dpx_frame_msgpack_from (frame.c:171)
==830==    by 0x4C149DB: _dpx_duplex_conn_read_frames (conn.c:60)
==830==    by 0x4E5948B: taskstart (task.c:71)
==830==    by 0x38594479FF: ??? (in /usr/lib64/libc-2.18.so)
==830== 
==830== 72 bytes in 1 blocks are definitely lost in loss record 66 of 83
==830==    at 0x4A0645D: malloc (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==830==    by 0x4C174BD: dpx_frame_new (frame.c:27)
==830==    by 0x402700: test_dpx_call (check.c:224)
==830==    by 0x4029E6: test_dpx_rpc_call (check.c:279)
==830==    by 0x526E87D: srunner_run (check_run.c:396)
==830==    by 0x40361A: main (check.c:499)
==830== 
==830== 288 bytes in 1 blocks are possibly lost in loss record 72 of 83
==830==    at 0x4A081D4: calloc (in /usr/lib64/valgrind/vgpreload_memcheck-amd64-linux.so)
==830==    by 0x3859011C44: _dl_allocate_tls (dl-tls.c:296)
==830==    by 0x3859808862: pthread_create@@GLIBC_2.2.5 (allocatestack.c:580)
==830==    by 0x4C1BCD5: dpx_init (dpx.c:172)
==830==    by 0x4028F1: test_dpx_rpc_call (check.c:263)
==830==    by 0x526E87D: srunner_run (check_run.c:396)
==830==    by 0x40361A: main (check.c:499)
==830== 
==830== LEAK SUMMARY:
==830==    definitely lost: 75 bytes in 2 blocks
==830==    indirectly lost: 0 bytes in 0 blocks
==830==      possibly lost: 288 bytes in 1 blocks
==830==    still reachable: 572,316 bytes in 93 blocks
==830==         suppressed: 0 bytes in 0 blocks
==830== Reachable blocks (those to which a pointer was found) are not shown.
==830== To see them, rerun with: --leak-check=full --show-leak-kinds=all
==830== 
==830== For counts of detected and suppressed errors, rerun with: -v
==830== ERROR SUMMARY: 7 errors from 4 contexts (suppressed: 2 from 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All that output looks, frankly, terrifying at first. But it&amp;rsquo;s actually not that
hard to interpret. It tells you how many blocks of memory it thinks are lost,
and where they were allocated. That&amp;rsquo;s it!&lt;/p&gt;

&lt;p&gt;How about output for invalid reads?&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t have those, because I rage&amp;hellip; obliterated them. Yes. That.&lt;/p&gt;

&lt;p&gt;My problem was that something was trying to write to the channel after it was
free&amp;rsquo;d. That has now been solved, thanks to valgrind outputting 8 pages of
&amp;ldquo;invalid write of size 8, here (insert stacktrace), to a block that was free&amp;rsquo;d
here (insert stacktrace)&amp;ldquo;.&lt;/p&gt;

&lt;h4 id=&#34;valgrind-treats-you-like-you-don-t-know-what-you-re-doing:8198804284f5f45e50df30e1088b1d71&#34;&gt;valgrind treats you like you don&amp;rsquo;t know what you&amp;rsquo;re doing&lt;/h4&gt;

&lt;p&gt;In my case, that&amp;rsquo;s probably true. Manual memory management sucks.&lt;/p&gt;

&lt;p&gt;But it&amp;rsquo;s good, because there&amp;rsquo;s definitely way more actual errors detected than
false positives. Case in point, here was my recycling bin after I printed out
my valgrind output and went through all of them one by one:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.robxu9.com/media/2014-08-05-valgrind-is-important/2014-08-05 18.05.13
.jpg&#34; alt=&#34;so much paper...&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;I feel old-fashioned because I do code reviews on paper, but hey, it&amp;rsquo;s easier
for me. I can&amp;rsquo;t be the only one who agrees&amp;hellip; right?&lt;/p&gt;

&lt;h4 id=&#34;so-what-are-you-trying-to-tell-me:8198804284f5f45e50df30e1088b1d71&#34;&gt;so what are you trying to tell me&lt;/h4&gt;

&lt;p&gt;Valgrind your program. It&amp;rsquo;s good for detecting memory leaks and the likes of it
, can tell you when you&amp;rsquo;re trying to murder poor memory fields you don&amp;rsquo;t have
access to, and also other cool things. Really.&lt;/p&gt;

&lt;p&gt;Here, I&amp;rsquo;ll get you started! You can run valgrind with
&lt;code&gt;valgrind --leak-check=yes --read-var-info=yes --track-origins=yes ./[program]&lt;/code&gt;
and receive your lovely output. By default, valgrind prints to stderr. Redirect
it to stdout if you want to pipe it to &lt;code&gt;ansi2html&lt;/code&gt; or something similar to
to print it out.&lt;/p&gt;

&lt;h4 id=&#34;what-was-the-point-of-this-article:8198804284f5f45e50df30e1088b1d71&#34;&gt;what was the point of this article&lt;/h4&gt;

&lt;p&gt;I don&amp;rsquo;t know, just that I had a problem, used Valgrind, solved said problem?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>